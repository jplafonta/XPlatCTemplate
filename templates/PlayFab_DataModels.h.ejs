// Copyright (c) Microsoft Corporation
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

#if !defined(__cplusplus)
#error C++11 required
#endif

#pragma once
<% if (api.name !== "Shared") { %>
#include <playfab/PlayFabSharedDataModels.h>
<% } 
if (api.name === "Client") { %>
#if HC_PLATFORM == HC_PLATFORM_GDK
#include <XUser.h>
#endif
<% } %>
extern "C"
{

#pragma push_macro("IN")
#undef IN
<% for (var enumIdx = 0; enumIdx < enumtypes.length; enumIdx++) { var enumtype = enumtypes[enumIdx]; %>
/// <summary>
/// <%- enumtype.name %> enum.
/// </summary>
enum class <%- prefix %><%- enumtype.name %> : uint32_t
{
    <% for(var i=0; i < enumtype.enumvalues.length-1; i++) { var enumval = enumtype.enumvalues[i]; %><%- enumval.name %>,
    <% } %><%- enumtype.enumvalues[enumtype.enumvalues.length-1].name %>
};
<% } // end for

if (api.name === "Shared") { %>
/// <summary>
/// String representation of a Json Object
/// </summary>
typedef struct PlayFabJsonObject
{
    const char* stringValue;
} PlayFabJsonObject;
<% }

for (var typeIdx = 0; typeIdx < sortedClasses.length; typeIdx++) { 
    var datatype = sortedClasses[typeIdx];
    if (datatype.isInternalOnly) {
        continue;
    } %>
/// <summary>
<%- getFormattedDatatypeDescription(prefix, datatype) %>
/// </summary>
typedef struct <%- prefix %><%- datatype.name %>
{<%
for (var propIdx = 0; propIdx < datatype.properties.length; propIdx++) { var property = datatype.properties[propIdx];
%><%- getPropertyDefinition("    ", datatype, property, prefix, false) %><% } %>
} <%- prefix %><%- datatype.name %>;
<% 
// Explicitly add LoginWithXUserRequest type alongside LoginWithXboxRequest
if (api.name === "Client" && datatype.name === "LoginWithXboxRequest") { %>
#if HC_PLATFORM == HC_PLATFORM_GDK
/// <summary>
/// PlayFabClientLoginWithXUserRequest data model. If this is the first time a user has signed in with
/// the Xbox Live account and CreateAccount is set to true, a new PlayFab account will be created and
/// linked to the Xbox Live account. In this case, no email or username will be associated with the PlayFab
/// account. Otherwise, if no PlayFab account is linked to the Xbox Live account, an error indicating
/// this will be returned, so that the title can guide the user through creation of a PlayFab account.
/// Request object for PlayFabClientLoginWithXUserAsync.
/// </summary>
typedef struct PlayFabClientLoginWithXUserRequest
{
    /// <summary>
    /// (Optional) Automatically create a PlayFab account if one is not currently linked to this ID.
    /// </summary>
    bool const* createAccount;

    /// <summary>
    /// (Optional) The optional custom tags associated with the request (e.g. build number, external
    /// trace identifiers, etc.).
    /// </summary>
    struct PlayFabStringDictionaryEntry const* customTags;

    /// <summary>
    /// Count of customTags
    /// </summary>
    uint32_t customTagsCount;

    /// <summary>
    /// (Optional) Flags for which pieces of info to return for the user.
    /// </summary>
    PlayFabClientGetPlayerCombinedInfoRequestParams const* infoRequestParameters;

    /// <summary>
    /// (Optional) Player secret that is used to verify API request signatures (Enterprise Only).
    /// </summary>
    const char* playerSecret;

    /// <summary>
    /// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab
    /// developer site when a title has been selected.
    /// </summary>
    const char* titleId;

    /// <summary>
    /// XUserHandle returned from XUserAddAsync or XUserAddByIdWithUiAsync.
    /// </summary>
    XUserHandle userHandle;

} PlayFabClientLoginWithXUserRequest;
#endif
<% } // end if
} // end for

if (api.name === "Shared") { %>
/// <summary>
/// Dictionary entry for an associative array with string values.
/// </summary>
typedef struct PlayFabStringDictionaryEntry
{
    const char* key;
    const char* value;
} PlayFabStringDictionaryEntry;

/// <summary>
/// Dictionary entry for an associative array with int32_t values.
/// </summary>
typedef struct PlayFabInt32DictionaryEntry
{
    const char* key;
    int32_t value;
} PlayFabInt32DictionaryEntry;

/// <summary>
/// Dictionary entry for an associative array with uint32_t values.
/// </summary>
typedef struct PlayFabUint32DictionaryEntry
{
    const char* key;
    uint32_t value;
} PlayFabUint32DictionaryEntry;

/// <summary>
/// Dictionary entry for an associative array with time_t values.
/// </summary>
typedef struct PlayFabDateTimeDictionaryEntry
{
    const char* key;
    time_t value;
} PlayFabDateTimeDictionaryEntry;
<% } // end if

for (var typeIdx in api.dictionaryEntryTypes) { var datatype = api.dictionaryEntryTypes[typeIdx]; %>
/// <summary>
/// Dictionary entry for an associative array with <%- prefix %><%- datatype.name %> values.
/// </summary>
typedef struct <%- prefix %><%- datatype.name %>DictionaryEntry
{
    const char* key;<%
if (datatype.isenum) { %>
    <%- prefix %><%- datatype.name %> value;
<% } else { %>
    <%- prefix %><%- datatype.name %>* value;<% } %>
} <%- prefix %><%- datatype.name %>DictionaryEntry;
<% } %>
#pragma pop_macro("IN")

}
