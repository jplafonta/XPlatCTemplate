#include "stdafx.h"
#include "Entity.h"

#define AS_STRING(charPtr) (charPtr ? String{ charPtr } : String{})

namespace PlayFab
{<% 
var apiInitializationList = "";
for(var apiName in categorizedApis) {
    var api = categorizedApis[apiName];
    if (api.otherCalls.length > 0 && !api.otherCallsRequireSecretKey) { 
        var apiMemberName = apiName.charAt(0).toLowerCase() + apiName.slice(1) + "API";
        apiInitializationList += "\n    " + apiMemberName + "{ m_httpClient, m_authTokens },";
    }
} %>

SharedPtr<Entity> Entity::Make(SharedPtr<HttpClient const> httpClient, const TaskQueue& backgroundQueue, LoginContext&& loginContext, const LoginResult& result)
{
    SharedPtr<Entity> entity{ new (Allocator<Entity>{}.allocate(1)) Entity{ std::move(httpClient), backgroundQueue, std::move(loginContext), result } };

    // Since this Entity is being created as a result of a title Login, schedule reauthentication
    entity->ScheduleReauthentication();

    return entity;
}

SharedPtr<Entity> Entity::Make(SharedPtr<HttpClient const> httpClient, const TaskQueue& backgroundQueue, LoginContext&& loginContext, const ClientModels::RegisterPlayFabUserResult& result)
{
    SharedPtr<Entity> entity{ new (Allocator<Entity>{}.allocate(1)) Entity{ std::move(httpClient), backgroundQueue, std::move(loginContext), result } };
    return entity;
}

SharedPtr<Entity> Entity::Make(SharedPtr<HttpClient const> httpClient, const TaskQueue& backgroundQueue, LoginContext&& loginContext, const AuthenticationModels::GetEntityTokenResponse& result)
{
    SharedPtr<Entity> entity{ new (Allocator<Entity>{}.allocate(1)) Entity{ std::move(httpClient), backgroundQueue, std::move(loginContext), result } };
    return entity;
}

Entity::Entity(SharedPtr<HttpClient const> httpClient, const TaskQueue& backgroundQueue, LoginContext&& loginContext, const LoginResult& result) :
    m_httpClient{ std::move(httpClient) },
    m_authTokens{ MakeShared<AuthTokens>(result) },
    m_backgroundQueue{ backgroundQueue.DeriveWorkerQueue() },
    eventManagerAPI{ m_httpClient, m_authTokens },
    QoSAPI{ m_httpClient, m_authTokens },<%- apiInitializationList %>
    m_loginContext{ std::move(loginContext) },
    m_playFabId{ result.playFabId },
    m_entityId{ AS_STRING(result.entityToken->entity->id) },
    m_entityType{ AS_STRING(result.entityToken->entity->type) },
    m_playerCombinedInfo{ result.infoResultPayload.has_value() ? MakeUnique<GetPlayerCombinedInfoResultPayload>(*result.infoResultPayload) : nullptr },
    m_lastLoginTime{ result.lastLoginTime },
    m_userSettings{ result.settingsForUser },
    m_treatmentAssignment{ result.treatmentAssignment.has_value() ? MakeUnique<PlayFab::TreatmentAssignment>(*result.treatmentAssignment) : nullptr }
{
}

Entity::Entity(SharedPtr<HttpClient const> httpClient, const TaskQueue& backgroundQueue, LoginContext&& loginContext, const ClientModels::RegisterPlayFabUserResult& result) :
    m_httpClient{ std::move(httpClient) },
    m_authTokens{ MakeShared<AuthTokens>(result) },
    m_backgroundQueue{ backgroundQueue.DeriveWorkerQueue() },
    eventManagerAPI{ m_httpClient, m_authTokens },
    QoSAPI{ m_httpClient, m_authTokens },<%- apiInitializationList %>
    m_loginContext{ std::move(loginContext) },
    m_playFabId{ result.playFabId },
    m_entityId{ AS_STRING(result.entityToken->entity->id) },
    m_entityType{ AS_STRING(result.entityToken->entity->type) },
    m_userSettings{ result.settingsForUser }
{
}

Entity::Entity(SharedPtr<HttpClient const> httpClient, const TaskQueue& backgroundQueue, LoginContext&& loginContext, const AuthenticationModels::GetEntityTokenResponse& result) :
    m_httpClient{ std::move(httpClient) },
    m_authTokens{ MakeShared<AuthTokens>(result) },
    m_backgroundQueue{ backgroundQueue.DeriveWorkerQueue() },
    eventManagerAPI{ m_httpClient, m_authTokens },
    QoSAPI{ m_httpClient, m_authTokens },<%- apiInitializationList %>
    m_loginContext{ std::move(loginContext) },
    m_entityId{ AS_STRING(result.entity->id) },
    m_entityType{ AS_STRING(result.entity->type) }
{
}

Entity::~Entity()
{
    // Queue is not shared (no one else will schedule work to this queue) so we can safely terminate here
    m_backgroundQueue.Terminate(true);
}

AsyncOp<SharedPtr<Entity>> Entity::GetEntityToken(
    const PlayFabAuthenticationGetEntityTokenRequest& request,
    const TaskQueue& queue
)
{
    UnorderedMap<String, String> headers;

    auto& entityToken{ m_authTokens->EntityToken() };
    auto sessionTicket{ m_authTokens->SessionTicket() };

    if (entityToken.token)
    {
        headers.emplace("X-EntityToken", entityToken.token);
    }
    else if (!sessionTicket.empty())
    {
        headers.emplace("X-Authorization", std::move(sessionTicket));
    }
    else
    {
        // Entity should always have at least one non-empty AuthToken
        assert(false);
        return E_UNEXPECTED;
    }

    return m_httpClient->MakePostRequest(
        "/Authentication/GetEntityToken",
        headers,
        JsonUtils::ToJson(request),
        queue
    ).Then([ sharedThis{ shared_from_this() } ](Result<ServiceResponse> result) mutable -> Result<SharedPtr<Entity>>
    {
        RETURN_IF_FAILED(result.hr);

        auto serviceResponse = result.ExtractPayload();
        if (serviceResponse.HttpCode == 200)
        {
            AuthenticationModels::GetEntityTokenResponse resultModel;
            resultModel.FromJson(serviceResponse.Data);

            if (sharedThis->m_entityId == AS_STRING(resultModel.entity->id))
            {
                // If we requested an EntityToken for ourselves, update m_authTokens and return "this"
                assert(sharedThis->m_entityType == AS_STRING(resultModel.entity->type));
                sharedThis->m_authTokens->Refresh(resultModel);
                return Result<SharedPtr<Entity>>{ std::move(sharedThis) };
            }
            else
            {
                // Otherwise create and return a new Entity object
                return Entity::Make(sharedThis->m_httpClient, TaskQueue{ sharedThis->m_backgroundQueue }, LoginContext{} /* TODO */, std::move(resultModel));
            }
        }
        else
        {
            return Result<SharedPtr<Entity>>{ ServiceErrorToHR(serviceResponse.ErrorCode), std::move(serviceResponse.ErrorMessage) };
        }
    });
}

String const& Entity::PlayFabId() const
{
    return m_playFabId;
}

String const& Entity::EntityId() const
{
    return m_entityId;
}

String const& Entity::EntityType() const
{
    return m_entityType;
}

PlayFab::EntityToken const& Entity::EntityToken() const
{
    return m_authTokens->EntityToken();
}

GetPlayerCombinedInfoResultPayload const* Entity::PlayerCombinedInfo() const
{
    return m_playerCombinedInfo.get();
}

time_t const* Entity::LastLoginTime() const
{
    return m_lastLoginTime.has_value() ? m_lastLoginTime.operator->() : nullptr;
}

UserSettings const* Entity::UserSettings() const
{
    return m_userSettings.has_value() ? m_userSettings.operator->() : nullptr;
}

TreatmentAssignment const* Entity::TreatmentAssignment() const
{
    return m_treatmentAssignment.get();
}

void Entity::ScheduleReauthentication()
{
    auto& entityToken{ m_authTokens->EntityToken() };
    if (!entityToken.expiration)
    {
        // If the entity token doesn't expire there is nothing to do.
        return;
    }

    // Schedule refresh for a minute prior to expiration TODO is there a better way to schedule this?
    auto delayInSeconds = std::min<int64_t>(static_cast<int64_t>((*entityToken.expiration) - time(nullptr) - 60), 0);

    m_backgroundQueue.RunWork([ weakThis = WeakPtr<Entity>{ shared_from_this() }, this ]
    {
        auto sharedThis{ weakThis.lock() };
        if (sharedThis)
        {
            UnorderedMap<String, String> headers;
            if (m_loginContext.secretKey)
            {
                headers.emplace("X-SecretKey", *m_loginContext.secretKey);
            }

            m_httpClient->MakePostRequest(
                m_loginContext.path.data(),
                headers,
                m_loginContext.requestBody,
                m_backgroundQueue
            ).Then([ weakThis, this ](Result<ServiceResponse> result)->Result<void>
            {
                auto sharedThis{ weakThis.lock() };

                RETURN_HR_IF(S_OK, !sharedThis); // Nothing to do if Title has cleaned up Entity
                RETURN_IF_FAILED(result.hr);

                auto serviceResponse = result.ExtractPayload();
                if (serviceResponse.HttpCode == 200)
                {
                    LoginResult resultModel;
                    resultModel.FromJson(serviceResponse.Data);
                    m_authTokens->Refresh(resultModel);
                }
                else
                {
                    return Result<void>{ ServiceErrorToHR(serviceResponse.ErrorCode), std::move(serviceResponse.ErrorMessage) };
                }
                return S_OK;

            }).Finally([ weakThis, this ](Result<void> result)
            {
                auto sharedThis{ weakThis.lock() };
                if (sharedThis)
                {
                    if (Succeeded(result))
                    {
                        // Schedule the next token refresh
                        ScheduleReauthentication();
                    }
                    else
                    {
                        // If Login call failed for any reason notify title. Entity object no unusable and title must re-login manually
                        AuthFailedCallbacks.Invoke(result.hr);
                    }
                }
            });
        }
    }, static_cast<uint32_t>(delayInSeconds * 1000));
}

}
